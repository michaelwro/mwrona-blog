<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Read Serial Data From Spektrum Remote Receiver - Michael Wrona&#39;s Blog</title><link rel="icon" type="image/png" href=/favicon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Read Serial Data From Spektrum Remote Receiver" />
<meta property="og:description" content="About six years ago, I purchased a Spektrum DX6i RC plane transmitter to fly my RC planes with. Unfortunately, life got busier and my interests shifted, which sent my planes and controller to retire in the basement. When the idea to build a quadcopter flight controller began to come to fruition, I knew my DX6i controller would be perfect!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mwrona.com/posts/03-read-spektrum-rem-data/" />
<meta property="article:published_time" content="2020-09-07T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-09-07T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Read Serial Data From Spektrum Remote Receiver"/>
<meta name="twitter:description" content="About six years ago, I purchased a Spektrum DX6i RC plane transmitter to fly my RC planes with. Unfortunately, life got busier and my interests shifted, which sent my planes and controller to retire in the basement. When the idea to build a quadcopter flight controller began to come to fruition, I knew my DX6i controller would be perfect!"/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://mwrona.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://mwrona.com/css/main.css" /><link rel="stylesheet" type="text/css" href="https://mwrona.com/css/dark.css"  />
	<link rel="stylesheet" type="text/css" href="https://mwrona.com/css/custom-dark.css"  />

	<script src="https://mwrona.com/js/feather.min.js"></script>
	
	<script src="https://mwrona.com/js/main.js"></script>

	<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title"><a href="https://mwrona.com/">Michael Wrona&#39;s Blog</a></h1>
	<div class="site-description"><h2>Engineering, coding, tech, and other cool projects!</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/michaelwro" title="Github"><i data-feather="github"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All Posts</a>
			</li>
			
			<li>
				<a href="/tags">Post Tags</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">Read Serial Data From Spektrum Remote Receiver</h1>
			<div class="meta">Posted at &mdash; Sep 7, 2020</div>
		</div>

		<div class="markdown">
			<p>About six years ago, I purchased a <a href="https://www.spektrumrc.com/Products/Default.aspx?ProdId=SPM6630">Spektrum DX6i</a> RC plane transmitter to fly my RC planes with. Unfortunately, life got busier and my interests shifted, which sent my planes and controller to retire in the basement. When the idea to build a quadcopter flight controller began to come to fruition, I knew my DX6i controller would be perfect! &ldquo;This is a cause worth coming out of retirement for, old one&rdquo; I said to my controller. His response: not powering on. I guess it&rsquo;s time for some fresh AA&rsquo;s.</p>
<h2 id="introduction">Introduction</h2>
<p>I was initially going to use my <a href="https://www.spektrumrc.com/Products/Default.aspx?ProdId=SPMAR6210">Spektrum AR6210 6-channel receiver</a> to provide pilot inputs to my quadcopter. I&rsquo;d use my microcontroller&rsquo;s digital pins to read the <a href="https://en.wikipedia.org/wiki/Pulse-width_modulation">PWM signals</a> from each channel. Unfortuantely, reading six PWM channels would require six individual servo cables running from the receiver to the microcontroller, which would look messy and add extra weight to the drone. Since this was basically my only option given the materials I had, I was willing to compromise.</p>
<p>I had always wondered what the little dongle-thingy was attached to my AR6210 receiver. I did some research and discovered this was a <a href="https://www.spektrumrc.com/Products/Default.aspx?ProdID=SPM9645">Spektrum DSMX Remote Receiver</a>. I did some more digging and found out that the three wires connecting the remote receiver to the AR6210 were power (+3.3V, orange), data (gray), and ground (black) wires. It turns out that the connection between the two was a serial connection that contained channel data! After this amazing discovery, I began reverse engineering the DSMX communication protocol and eventually succeeded: I figured out how to extract the six channel/transmitter stick positions from the DSMX serial byte stream. Now, time to tell you how to do the same!</p>

<figure class="center" >
  <a href="/post-imgs/03-read-spektrum-sat-data/rem-rec-and-rc-rec.jpg" target="_blank">
    <img src="/post-imgs/03-read-spektrum-sat-data/rem-rec-and-rc-rec.jpg"  alt="Remote Receiver and RC Receiver"   width="400px"   style="border-radius: 8px;"  />
  </a>
  
    <figcaption class="center" >Spektrum Remote Receiver and AR6210 RC Receiver.</figcaption>
  
</figure>

<p>First, I&rsquo;ll describe the DSMX communication protocol and serial packet structure. Next, I&rsquo;ll outline my hardware testing setup and wiring. Finally, I&rsquo;ll dive deep into the Arduino code I developed to read and process the remote receiver&rsquo;s serial data stream.</p>
<h2 id="dsmx-communication-protocol">DSMX Communication Protocol</h2>
<p><strong>Datasheet Reference:</strong> The official data sheet describing the Spektrum Remote Receiver communication protol can be found <a href="https://www.spektrumrc.com/ProdInfo/Files/Remote%20Receiver%20Interfacing%20Rev%20A.pdf">at this link</a>.</p>
<p>The serial communication protocol used by Spektrum Remote Receivers consists of 16-byte transmission packets. There are four different serial communication protocols used by the receivers, differentiated by the timing between transmissions and channel data ranges.</p>
<table>
<thead>
<tr>
<th align="left">Protocol</th>
<th align="center">ID Byte</th>
<th align="center">TX Timing</th>
<th align="center">Ch. Data Range</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><strong>11ms/2048 DSM2</strong></td>
<td align="center">0x12</td>
<td align="center">11ms</td>
<td align="center">0 &hellip; 2048</td>
</tr>
<tr>
<td align="left"><strong>22ms/1024 DSM2</strong></td>
<td align="center">0x01</td>
<td align="center">22ms</td>
<td align="center">0 &hellip; 1024</td>
</tr>
<tr>
<td align="left"><strong>11ms/2048 DSMX</strong></td>
<td align="center">0xB2</td>
<td align="center">11ms</td>
<td align="center">0 &hellip; 2048</td>
</tr>
<tr>
<td align="left"><strong>22ms/2048 DSMX</strong>*</td>
<td align="center">0xA2</td>
<td align="center">22ms</td>
<td align="center">0 &hellip; 2048</td>
</tr>
</tbody>
</table>
<p>The timing between each serial data packet transmission is either 11ms or 22ms, and the channel data ranges from zero to either 1024 or 2048. <strong>My particular Remote Receiver used the 22ms/2048 DSMX (denoted by *) protocol.</strong> I am assuming this is the most common.</p>
<h3 id="packet-structure">Packet Structure</h3>
<p>Each 16-byte serial data packet has the following structure:</p>


<table>
    <tr>
        <th>Byte Index</th>
        <td>0</td>
        <td>1</td>
        <td>2 ... 15</td>
    </tr>
    <tr>
        <th>Field Name</th>
        <td>Fades</td>
        <td>Proto. ID</td>
        <td>ServoData[7]</td>
    </tr>
    <tr>
        <th>Data Type</th>
        <td>uint8_t</td>
        <td>uint8_t</td>
        <td>uint16_t</td>
    </tr>
</table>

<p>The first byte in the transmission is referred to as &lsquo;fades&rsquo; in Spektrum&rsquo;s datasheet. This is a count of how many data packets were missed by the remote receiver. My receiver never missed any frames during testing (even when I did a range test), so I guess there&rsquo;s no need to keep track of this value in your code. The second byte is the protocol ID byte. This important byte&rsquo;s value indicates which protocol the remote receiver uses. Finally, the remaining 14 bytes in the serial packet describe the seven channel&rsquo;s values/positions. These are <a href="https://en.wikipedia.org/wiki/Endianness">big-endian</a> unsigned 16-bit values. Therefore, each channel&rsquo;s data is in groups of two 8-bit unsigned values. Each of these groups have the following bit-structure:</p>


<table>
    <tr>
        <th>Bit 15</th>
        <td>Channel phase</td>
    </tr>
    <tr>
        <th>Bits 14 - 11</th>
        <td>Channel ID</td>
    </tr>
    <tr>
        <th>Bits 10 - 0</th>
        <td>Channel Value</td>
    </tr>
</table>

<p>This will begin to make more sense when I describe my data processing code down below.</p>
<h2 id="hardware-setup-and-wiring">Hardware Setup and Wiring</h2>
<h3 id="custom-plug-adapter">Custom Plug Adapter</h3>
<p>In order to make the remote receiver breadboard-compatible, I needed to make my own custom adapter. I bought an additional <a href="https://www.amazon.com/gp/product/B000ND6IXW/ref=ppx_yo_dt_b_asin_title_o07_s00?ie=UTF8&amp;psc=1">remote receiver cable</a> and soldered its wires to the wires of a standard servo connector (see image below).</p>

<figure class="center" >
  <a href="/post-imgs/03-read-spektrum-sat-data/rec-wire-conv.jpg" target="_blank">
    <img src="/post-imgs/03-read-spektrum-sat-data/rec-wire-conv.jpg"  alt="Custom wire adaptor."   width="400px"   style="border-radius: 8px;"  />
  </a>
  
    <figcaption class="center" >Custom adapter to convert the remote receiver connector to a standard servo plug.</figcaption>
  
</figure>


<figure class="center" >
  <a href="/post-imgs/03-read-spektrum-sat-data/wiring.jpg" target="_blank">
    <img src="/post-imgs/03-read-spektrum-sat-data/wiring.jpg"  alt="Setup wiring."   width="400px"   style="border-radius: 8px;"  />
  </a>
  
    <figcaption class="center" >Hardware setup and circuit wiring.</figcaption>
  
</figure>

<h3 id="wiring-it-up">Wiring it Up</h3>
<p><strong>IMPORTANT: THE REMOTE RECEIVER REQUIRES +3.3V ONLY!</strong> Do not connect more than +3.3V to the remote receiver&rsquo;s power line!</p>
<p>I used an Arduino Uno to read the serial data stream from the remote receiver and an external +5V / +3.3V power supply to power the circuit. I suspected that I might run into current draw limitations on the Uno&rsquo;s 3.3V supply, so I instead used an external 3.3V power supply for the remote receiver. I also powered the Uno with a 5V output from the external supply via the Uno&rsquo;s Vin pin. I then connected the remote receiver&rsquo;s serial data wire to Arduino Uno pin 2. I used the Arduino <a href="https://www.arduino.cc/en/Reference/softwareSerial">SoftwareSerial library</a> to read the serial stream.</p>
<h2 id="software">Software</h2>
<p>In order to determine which protocol my remote receiver used, I probed its serial output via a serial-to-USB converter and <a href="https://www.eltima.com/products/serial-port-monitor/">serial port monitoring software</a>. I figured out which protocol was used by comparing the second byte of each serial message to the datasheet. Mine ended up using the 22ms/2048 DSMX protocol.</p>

<figure class="center" >
  <a href="/post-imgs/03-read-spektrum-sat-data/ftdi-wiring.jpg" target="_blank">
    <img src="/post-imgs/03-read-spektrum-sat-data/ftdi-wiring.jpg"  alt="Serial to USB wiring."   width="400px"   style="border-radius: 8px;"  />
  </a>
  
    <figcaption class="center" >Wiring for the serial to USB converter.</figcaption>
  
</figure>

<h3 id="getting-serial-data">Getting Serial Data</h3>
<p>I used the SoftwareSerial library to &lsquo;convert&rsquo; Arduino Uno pin 2 to a serial input. I labelled this serial port as <code>Serial1</code>. <strong>The default baud rate for the remote reciever is 115200!</strong></p>
<p>In the Arduino&rsquo;s <code>loop()</code> function, I had the Uno listen to the remote receiver&rsquo;s serial connection until it received a serial byte. When a byte was received, the byte was then passed on to my processing function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">SoftwareSerial <span style="color:#a6e22e">Serial1</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// (rx, tx) receiver&#39;s serial port
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup</span>() {
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Serial);  <span style="color:#75715e">// Wait for serial console to open
</span><span style="color:#75715e"></span>    Serial.begin(<span style="color:#ae81ff">115200</span>);  <span style="color:#75715e">// Arduino&#39;s port
</span><span style="color:#75715e"></span>    Serial1.begin(<span style="color:#ae81ff">115200</span>);  <span style="color:#75715e">// Spektrum&#39;s port
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop</span>() {
    <span style="color:#66d9ef">if</span> (Serial1.available() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">uint8_t</span> incomingByte <span style="color:#f92672">=</span> Serial1.read();  <span style="color:#75715e">// Get data!
</span><span style="color:#75715e"></span>        processByte(incomingByte);
    }
}
</code></pre></div><h3 id="processing-the-data">Processing the Data</h3>
<p>The incoming bytes from the remote receiver needed to be stored in an array for processing. In order to figure out what array index to put the incoming byte into, I needed to figure out some logic to determine the proper index. As described in the datasheet, there was a 22ms delay between each data frame. Therefore, if the time between the current and previous receive was greater than about 10ms, the current byte was the first in a new transmission. I used a counter variable as an array index. Every time a new serial byte was received, the counter/array index was incremented by one. The array index variable was reset to zero when it reached 15, a full frame (the end of the array). Once a full data frame was received and the data array was full, the frame was passed on to another function to extract the channel/servo data.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processByte</span>(<span style="color:#66d9ef">uint8_t</span> inByte) {
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> currTime <span style="color:#f92672">=</span> millis();
    <span style="color:#66d9ef">if</span> (currTime <span style="color:#f92672">-</span> prevUpdateTime <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span>) {
        <span style="color:#75715e">// 22ms delay between data frames has passed, reset index
</span><span style="color:#75715e"></span>        byteIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }

    dataBytes[byteIndex] <span style="color:#f92672">=</span> inByte;  <span style="color:#75715e">// Add byte to array
</span><span style="color:#75715e"></span>    byteIndex<span style="color:#f92672">++</span>;

    <span style="color:#66d9ef">if</span> (byteIndex <span style="color:#f92672">==</span> <span style="color:#66d9ef">sizeof</span>(dataBytes)) {  <span style="color:#75715e">// If the index is at 16
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// dataBytes is full, time to parse and extract channel 
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// data/servo positions
</span><span style="color:#75715e"></span>        processFrame();
        byteIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        frameCount<span style="color:#f92672">++</span>;
    }

    <span style="color:#75715e">// currTime and prevUpdateTime will be very close when receiving bytes in 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// quick succession When the frame transmission is done, the time will 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// hold constant. Then, when a new frame comes along, the time difference 
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// will be large
</span><span style="color:#75715e"></span>    prevUpdateTime <span style="color:#f92672">=</span> currTime;
}
</code></pre></div><h3 id="extracting-channel-data">Extracting Channel Data</h3>
<p>Before processing each frame and extracting channel data/servo positions, some error-checking was performed to validate the frame was correct. Then, bit masking and bitwise operations were perfomed to extract each channel&rsquo;s data.</p>
<p>Recall that the first byte in each frame is the number of frames the remote receiver missed or dropped. This never changed from zero during my testing, so I never used this value for anything. However, the second byte in each frame was very important. The value of this byte describes the protocol used by the remote receiver. My receiver&rsquo;s was <code>0xA2</code>, which corresponded to the 22ms/2048 DSMX protocol. For some reason, the ID byte occasionally switched to <code>0xA1</code> or <code>0xA3</code> for a single frame. The rest of the frame seemed normal, but just as a safeguard, I ignored every frame whose ID wasn&rsquo;t <code>0xA2</code>.</p>
<p>Recall that the third through 16th byte in each frame contains the channel data as big-endian 16-bit unsigned integers. Every pair of bytes were parsed. The first byte byte in each pair was the &lsquo;high&rsquo; byte, and second was the &lsquo;low&rsquo; byte. First, the channel ID (number) was extracted from the high byte via bitwise operations. Next, the pair of big-endian bytes were converted to standard <code>uint16_t</code> type via bitwise operations to compute the corresponding channel&rsquo;s value. The result was masked with <code>0x07FF</code>, which is 2047 in hex.</p>
<p>Next, I converted the channel&rsquo;s value to fall within the standard servo PWM signal pulse width: between 1000us and 2000us, centered at 1500us. The remote receiver&rsquo;s datasheet gave an equation to do this. Finally, the channel value was stored in an array, with its index corresponding to the the channel&rsquo;s ID. Sometimes, the channel ID exceeded 6 for some reason, so I therefore ignored those values.</p>
<p>Also, I stored the previous valid readings just in case an error occurred.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processFrame</span>() {
    <span style="color:#75715e">// Expects second byte (protocol ID) to be 0xA2.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// If not, use previous valid data
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dataBytes[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xA2</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint8_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">sizeof</span>(dataBytes); i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>) {
            <span style="color:#66d9ef">uint8_t</span> hiByte <span style="color:#f92672">=</span> dataBytes[i];
            <span style="color:#66d9ef">uint8_t</span> loByte <span style="color:#f92672">=</span> dataBytes[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
            <span style="color:#66d9ef">uint16_t</span> servoVal;
            <span style="color:#66d9ef">uint8_t</span> chanID <span style="color:#f92672">=</span> (hiByte <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xf</span>;  <span style="color:#75715e">// Extract channel ID
</span><span style="color:#75715e"></span>
            <span style="color:#75715e">// Make sure channel ID is less than 6 (range from 0 to 6)
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (chanID <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">6</span>) {
                <span style="color:#75715e">// Convert two bytes in big-endian to int
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// https://stackoverflow.com/a/2660326
</span><span style="color:#75715e"></span>                servoVal <span style="color:#f92672">=</span> ((hiByte <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> loByte) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x07FF</span>;

                <span style="color:#75715e">// Constrain values to a range, just in case an error occurs
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (servoVal <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">300</span>)
                    servoVal <span style="color:#f92672">=</span> <span style="color:#ae81ff">300</span>;

                <span style="color:#66d9ef">if</span> (servoVal <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1730</span>)
                    servoVal <span style="color:#f92672">=</span> <span style="color:#ae81ff">1730</span>;

                <span style="color:#75715e">// Use equation in DSMX datasheet to convert [0 2048] values
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// to standard PWM range [~1000ms ~2000ms] with center at 1500ms
</span><span style="color:#75715e"></span>                servo[chanID] <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0.583f</span> <span style="color:#f92672">*</span> servoVal) <span style="color:#f92672">+</span> <span style="color:#ae81ff">903</span>;
            }
        }
        <span style="color:#75715e">// memcpy(dest, src, sizeof);
</span><span style="color:#75715e"></span>        memcpy(prevDataBytes, dataBytes, <span style="color:#66d9ef">sizeof</span>(dataBytes));
        memcpy(prevServo, servo, <span style="color:#66d9ef">sizeof</span>(servo));
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// Bad reading, use previous (valid) data
</span><span style="color:#75715e"></span>        memcpy(dataBytes, prevDataBytes, <span style="color:#66d9ef">sizeof</span>(prevDataBytes));
        memcpy(servo, prevServo, <span style="color:#66d9ef">sizeof</span>(prevServo));
        numBadReadings<span style="color:#f92672">++</span>;
    }
}
</code></pre></div><h2 id="results">Results</h2>
<p>I am very happy with the results of my code. It was able to read the six channels coming from my transmitter without error. The code is relatively light weight, both in terms of memory and computation time. Before I implement this on board my flight computer, I will likely add a few more error checks, just to be extra safe.</p>
<h2 id="code">Code</h2>
<p>Here is the entire Arduino code I wrote. Please cite my blog if you plan on using it in your project!</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">
<span style="color:#75715e">// ----------------------------------------------------------------------------
</span><span style="color:#75715e">// READ RC CHANNEL DATA FROM SPEKTRUM DSMX REMOTE RECEIVER
</span><span style="color:#75715e">// 
</span><span style="color:#75715e">// Code By: Michael Wrona | mwrona.com
</span><span style="color:#75715e">// ----------------------------------------------------------------------------
</span><span style="color:#75715e"></span><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Sample Packet:
</span><span style="color:#75715e"> *  00 a2 0b fe 2b fe 13 fe 21 32 1b fe 30 00 01 30
</span><span style="color:#75715e"> *  ChID: 1     5     2     4     3     6     0
</span><span style="color:#75715e"> */</span>


<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;SoftwareSerial.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processByte</span>(<span style="color:#66d9ef">uint8_t</span> inByte);
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processFrame</span>();

<span style="color:#66d9ef">uint8_t</span> byteIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">uint8_t</span> frameCount <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// Number of evaluated frames
</span><span style="color:#75715e"></span><span style="color:#66d9ef">uint8_t</span> dataBytes[<span style="color:#ae81ff">16</span>];  <span style="color:#75715e">// Array to store the entire 16 byte packet
</span><span style="color:#75715e"></span><span style="color:#66d9ef">uint8_t</span> prevDataBytes[<span style="color:#ae81ff">16</span>];  <span style="color:#75715e">// Store prev. ver. in case of data read error
</span><span style="color:#75715e"></span><span style="color:#66d9ef">uint16_t</span> servo[<span style="color:#ae81ff">7</span>];  <span style="color:#75715e">// Array to hold channel data (7 in total)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">uint16_t</span> numBadReadings <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// Number of missed frames (counter)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">uint16_t</span> prevServo[<span style="color:#ae81ff">7</span>];  <span style="color:#75715e">// Store prev. correct readings
</span><span style="color:#75715e"></span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> prevUpdateTime <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

SoftwareSerial <span style="color:#a6e22e">Serial1</span>(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);  <span style="color:#75715e">// Spektrum serial port
</span><span style="color:#75715e"></span>

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setup</span>() {
    <span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>Serial);  <span style="color:#75715e">// Wait for serial console to open
</span><span style="color:#75715e"></span>    Serial.begin(<span style="color:#ae81ff">115200</span>);  <span style="color:#75715e">// Arduino&#39;s port
</span><span style="color:#75715e"></span>    Serial1.begin(<span style="color:#ae81ff">115200</span>);  <span style="color:#75715e">// Spektrum&#39;s port
</span><span style="color:#75715e"></span>}


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop</span>() {
    <span style="color:#66d9ef">if</span> (Serial1.available() <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        <span style="color:#66d9ef">uint8_t</span> incomingByte <span style="color:#f92672">=</span> Serial1.read();  <span style="color:#75715e">// Get data!
</span><span style="color:#75715e"></span>        processByte(incomingByte);
    }
}


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processByte</span>(<span style="color:#66d9ef">uint8_t</span> inByte) {
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> currTime <span style="color:#f92672">=</span> millis();
    <span style="color:#66d9ef">if</span> (currTime <span style="color:#f92672">-</span> prevUpdateTime <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">10</span>) {
        <span style="color:#75715e">// 22ms delay between data frames has passed, reset index
</span><span style="color:#75715e"></span>        byteIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }

    dataBytes[byteIndex] <span style="color:#f92672">=</span> inByte;  <span style="color:#75715e">// Add byte to array
</span><span style="color:#75715e"></span>    byteIndex<span style="color:#f92672">++</span>;

    <span style="color:#66d9ef">if</span> (byteIndex <span style="color:#f92672">==</span> <span style="color:#66d9ef">sizeof</span>(dataBytes)) {  <span style="color:#75715e">// If the index is at 16
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// dataBytes is full, time to parse and extract channel
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// data/servo positions
</span><span style="color:#75715e"></span>        processFrame();
        byteIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        frameCount<span style="color:#f92672">++</span>;
    }

    <span style="color:#75715e">// currTime and prevUpdateTime will be very close when receiving bytes in
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// quick succession When the frame transmission is done, the time will
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// hold constant. Then, when a new frame comes along, the time difference
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// will be large
</span><span style="color:#75715e"></span>    prevUpdateTime <span style="color:#f92672">=</span> currTime;
}


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">processFrame</span>() {
    <span style="color:#75715e">// Expects second byte (protocol ID) to be 0xA2.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// If not, use previous valid data
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dataBytes[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xA2</span>) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">uint8_t</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">sizeof</span>(dataBytes); i <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>) {
            <span style="color:#66d9ef">uint8_t</span> hiByte <span style="color:#f92672">=</span> dataBytes[i];
            <span style="color:#66d9ef">uint8_t</span> loByte <span style="color:#f92672">=</span> dataBytes[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
            <span style="color:#66d9ef">uint16_t</span> servoVal;
            <span style="color:#66d9ef">uint8_t</span> chanID <span style="color:#f92672">=</span> (hiByte <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xf</span>;  <span style="color:#75715e">// Extract channel ID
</span><span style="color:#75715e"></span>
            <span style="color:#75715e">// Make sure channel ID is less than 6 (range from 0 to 6)
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (chanID <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">6</span>) {
                <span style="color:#75715e">// Convert two bytes in big-endian to int
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// https://stackoverflow.com/a/2660326
</span><span style="color:#75715e"></span>                servoVal <span style="color:#f92672">=</span> ((hiByte <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">|</span> loByte) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x07FF</span>;

                <span style="color:#75715e">// Constrain values to a range, just in case an error occurs
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (servoVal <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">300</span>)
                    servoVal <span style="color:#f92672">=</span> <span style="color:#ae81ff">300</span>;

                <span style="color:#66d9ef">if</span> (servoVal <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1730</span>)
                    servoVal <span style="color:#f92672">=</span> <span style="color:#ae81ff">1730</span>;

                <span style="color:#75715e">// Use equation in DSMX datasheet to convert [0 2048] values
</span><span style="color:#75715e"></span>                <span style="color:#75715e">// to standard PWM range [~1000ms ~2000ms] with center at 1500ms
</span><span style="color:#75715e"></span>                servo[chanID] <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0.583f</span> <span style="color:#f92672">*</span> servoVal) <span style="color:#f92672">+</span> <span style="color:#ae81ff">903</span>;
            }
        }
        <span style="color:#75715e">// memcpy(dest, src, sizeof);
</span><span style="color:#75715e"></span>        memcpy(prevDataBytes, dataBytes, <span style="color:#66d9ef">sizeof</span>(dataBytes));
        memcpy(prevServo, servo, <span style="color:#66d9ef">sizeof</span>(servo));
    }
    <span style="color:#66d9ef">else</span> {
        <span style="color:#75715e">// Bad reading, use previous (valid) data
</span><span style="color:#75715e"></span>        memcpy(dataBytes, prevDataBytes, <span style="color:#66d9ef">sizeof</span>(prevDataBytes));
        memcpy(servo, prevServo, <span style="color:#66d9ef">sizeof</span>(prevServo));
        numBadReadings<span style="color:#f92672">++</span>;
    }
}
</code></pre></div>
		</div>

		<div class="post-tags">
			
				
					<nav class="nav tags">
							<ul class="flat">
								
								<li><a href="/tags/arduino">arduino</a></li>
								
								<li><a href="/tags/circuits">circuits</a></li>
								
								<li><a href="/tags/c&#43;&#43;">c&#43;&#43;</a></li>
								
								<li><a href="/tags/drone">drone</a></li>
								
								<li><a href="/tags/programming">programming</a></li>
								
							</ul>
					</nav>
				
			
		</div>
		</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> Copyright © Michael Wrona 2020 |  <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-176773333-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>feather.replace()</script>
</body>
</html>
