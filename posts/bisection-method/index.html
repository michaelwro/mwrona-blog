<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>The Bisection Method - Theory and Code - Michael Wrona&#39;s Blog</title><link rel="icon" type="image/png" href=/favicon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="The Bisection Method - Theory and Code" />
<meta property="og:description" content="Introduction The first few algorithms introduced in numerical methods courses are typically root-finding algorithms. In my opinion, these algorithms are taught first because they are relatively easy to understand and code, and determining roots of a function is a very common math operation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mwrona.com/posts/bisection-method/" />
<meta property="article:published_time" content="2020-12-10T00:00:00+00:00" />
<meta property="article:modified_time" content="2020-12-10T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Bisection Method - Theory and Code"/>
<meta name="twitter:description" content="Introduction The first few algorithms introduced in numerical methods courses are typically root-finding algorithms. In my opinion, these algorithms are taught first because they are relatively easy to understand and code, and determining roots of a function is a very common math operation."/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://mwrona.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://mwrona.com/css/main.css" /><link rel="stylesheet" type="text/css" href="https://mwrona.com/css/dark.css"  />
	<link rel="stylesheet" type="text/css" href="https://mwrona.com/css/custom-dark.css"  />

	<script src="https://mwrona.com/js/feather.min.js"></script>
	
	<script src="https://mwrona.com/js/main.js"></script>

	<script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[', '\\]']],
        processEscapes: true,
        processEnvironments: true,
        tags: 'ams'
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  
    window.addEventListener('load', (event) => {
        document.querySelectorAll("mjx-container").forEach(function(x){
          x.parentElement.classList += 'has-jax'})
      });
  
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title"><a href="https://mwrona.com/">Michael Wrona&#39;s Blog</a></h1>
	<div class="site-description"><h2>Engineering, coding, tech, and other cool projects!</h2><nav class="nav social">
			<ul class="flat"><a href="https://www.youtube.com/channel/UCIeZzuXHGm7zqSFvT8xGoIQ" title="YouTube: @MicWro Engr" target="_blank" rel="noopener noreferrer"><i data-feather="youtube"></i></a><a href="https://github.com/michaelwro" title="GitHub: @michaelwro" target="_blank" rel="noopener noreferrer"><i data-feather="github"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All Posts</a>
			</li>
			
			<li>
				<a href="/tags">Post Tags</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">The Bisection Method - Theory and Code</h1>
			<div class="meta">Posted at &mdash; Dec 10, 2020</div>
		</div>

		<div class="markdown">
			<h2 id="introduction">Introduction</h2>
<p>The first few algorithms introduced in numerical methods courses are typically root-finding algorithms. In my opinion, these algorithms are taught first because they are relatively easy to understand and code, and determining roots of a function is a very common math operation. They also introduce fundamental numerical analysis topics, such as convergence criteria and iterative operations.</p>
<dl>
<dt>A root, or zero, of a function  <code>$f$</code>  is a point  <code>$x_0$</code>  that satisfies <code>$f(x_0) = 0$</code>. An arbitrary function may have multiple roots. The Bisection Method is one of the most utilized root-finding algorithms due to its simplicity. Note that the Bisection Method is also sometimes referred to as the Binary-Search Method. The Bisection Method is derived from the Intermediate Value Theorem. In this context, the Intermediate Value Theorem is defined as:</dt>
<dd>
<p><em>For some function <code>$f(x)$</code> that is defined on the interval <code>$[a, b]$</code>, if the sign of <code>$f(a)$</code> and <code>$f(b)$</code> is opposite, there must exist a value <code>$p$</code> such that <code>$f(p) = 0$</code>.</em></p>
</dd>
</dl>
<p>I&rsquo;ll translate this definition into something more general. Root-finding numerical methods typically accept a function and boundary points (x-values) where we believe a root lies. The lower(left) bound is <code>$x = a$</code> and the upper (right) bound is <code>$x = b$</code>. First, we need to make sure our function <code>$f(x)$</code> is continuous and exists between our boundaries <code>$[a, b]$</code>. An easy way to verify this is to plot the function. Next, we evaluate our function at <code>$x = a$</code> and <code>$x = b$</code>, i.e. determine <code>$f(a)$</code> and <code>$f(b)$</code>. If the signs of <code>$f(a)$</code> and <code>$f(b)$</code> differ, the function must have crossed zero at some point within <code>$[a, b]$</code>. This means that there must be some point <code>$x = p$</code> where the function crossed the x-axis, or in other words, make <code>$f(p) = 0$</code> - a root!</p>
<h2 id="the-bisection-method">The Bisection Method</h2>
<p>Next, I&rsquo;ll explain how the Bisection Method determines roots. The first step is choosing initial <code>$a$</code> and <code>$b$</code> boundary values that we believe the root is within. Let&rsquo;s call these <code>$a_1$</code> and <code>$b_1$</code>. Next, we determine the midpoint <code>$p_1$</code> between <code>$a$</code> and <code>$b$</code> via:</p>
<p><code>$$p_1 = a_1 + \frac{b_1 - a_1}{2} = \frac{a_1 + b_1}{2}$$</code></p>
<p>Then, the boundary points <code>$a$</code> and <code>$b$</code> and the computed midpoint <code>$p$</code> can be compared:</p>
<ul>
<li>If <code>$f(p_1)$</code> and <code>$f(a_1)$</code> have the same sign, <code>$p$</code> must exist between <code>$p_1$</code> and <code>$b_1$</code>.</li>
<li>If <code>$f(p_1)$</code> and <code>$f(a_1)$</code> have opposite signs, <code>$p$</code> must exist between <code>$a_1$</code> and <code>$p_1$</code>.</li>
</ul>
<p>This relationship can be seen in Figure 1. Since $f(p_1)$ and $f(a_1)$ have the same sign in Figure 1, the root must lie between $p_1$ and $b_1$. Then, we can update the new interval to be $p_1$ and $b_1$. Therefore, we can set $a_2 = p_1$ and $b_2 = b_1$. Then, using the above equation, a new midpoint $p_2$ can be computed. The sign check is performed again, and a new interval is determined. This continues until the interval becomes sufficiently small, with the root approximation at the midpoint of the small interval.</p>

<figure class="center" >
  <a href="/post-imgs/bisection-method/bisect-illustration.png" target="_blank">
    <img src="/post-imgs/bisection-method/bisect-illustration.png"  alt="Bisect Method Visualization"   width="500px"   style="border-radius: 8px;"  />
  </a>
  
    <figcaption class="center" >Figure 1. Visualization of the bisection method.</figcaption>
  
</figure>

<hr>
<h2 id="bisection-method-steps">Bisection Method Steps</h2>
<p>The steps for the Bisection Method looks something like:</p>
<ul>
<li>Choose initial boundary points <code>$a_1$</code> and <code>$b_1$</code>.</li>
<li>Compute the midpoint <code>$p_1 = \frac{a_1 + b_1}{2}$</code>.</li>
<li>Determine the new interval:
<ul>
<li>If <code>$f(p_1)$</code> and <code>$f(a_1)$</code> have the same sign, set <code>$a_2 = p_1$</code> and <code>$b_2 = b_1$</code>.</li>
<li>If <code>$f(p_1)$</code> and <code>$f(a_1)$</code> have opposite signs, set <code>$a_2 = a_1$</code> and <code>$b_2 = p_1$.</code></li>
</ul>
</li>
<li>Repeat until interval <code>$[a_n, b_n]$</code> becomes sufficiently small.</li>
</ul>
<hr>
<h2 id="pros-and-cons">Pros and Cons</h2>
<h3 id="advantages">Advantages</h3>
<ul>
<li>Easy to understand conceptually.</li>
<li>Easy to implement in code.</li>
<li>Always will converge to a solution, but not necessarily the correct one.</li>
</ul>
<h3 id="drawbacks">Drawbacks</h3>
<ul>
<li>Relatively slow to converge compared to other methods (takes more iterations).</li>
<li>Doesn&rsquo;t work well when the root is located where the function is flat (near-zero slope).</li>
<li>Convergence speed depends on how &lsquo;wide&rsquo; the initial interval is (smaller = faster).</li>
</ul>
<hr>
<h2 id="convergence-check">Convergence Check</h2>
<p>As the Bisection Method converges to a zero, the interval <code>$[a_n, b_n]$</code> will become smaller. To check if the Bisection Method converged to a small interval width, the following inequality should be true:</p>
<p><code>$$\frac{b - a}{2} &lt; \epsilon$$</code></p>
<p>The Greek letter epsilon, <code>$\epsilon$</code>, is commonly used to denote tolerance. In code, I like to use the variable name <code>TOL</code>. The above convergence check is very easy to implement and works just fine. Another way to check convergence is by computing the change in the value of <code>$p$</code> between the current (<code>$i$</code>) and prevoius (<code>$i-1$</code>) iteration.</p>
<p><code>$$\frac{|p_i - p_{i-1}|}{p_i} &lt; \epsilon$$</code></p>
<p>Both ways work fine, but I personally prefer to use the second method, as it is a convergence criteria for many other numerical methods.</p>
<hr>
<h2 id="code-implementation-python">Code Implementation (Python)</h2>
<p>So, now that we understand how the Bisection Method works, let&rsquo;s code it. We will try to find a value of <code>$x$</code> that solves:</p>
<p><code>$$xe^{2x} - \sqrt{x} = 4x$$</code></p>
<p>We can rearrange the equation such that one side of the equation is equal to zero:</p>
<p><code>$$f(x) = xe^{2x} - \sqrt{x} - 4x = 0$$</code></p>
<p>Let&rsquo;s define this in Python code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np
<span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#f92672">as</span> plt

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">funct</span>(x):
    fx <span style="color:#f92672">=</span> (x <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>exp(<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> x)) <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>sqrt(x) <span style="color:#f92672">-</span> (<span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> x)
    <span style="color:#66d9ef">return</span> fx
</code></pre></div><p>Upon inspection of <code>$f(x)$</code>, one solution/root of the equation is <code>$x = 0$</code>. This is a trivial solution, however. Let&rsquo;s plot it to determine where the other solution/root is.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">x_points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">80</span>)  <span style="color:#75715e"># Points to pass to function</span>

plt<span style="color:#f92672">.</span>figure()  <span style="color:#75715e"># Plot f(x)</span>
plt<span style="color:#f92672">.</span>plot(x_points, funct(x_points))
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;$f(x) = xe^{2x} - \sqrt{x} - 4x$&#39;</span>)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#39;x&#39;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;f(x)&#39;</span>)
plt<span style="color:#f92672">.</span>grid()
</code></pre></div>
<figure class="center" >
  <a href="/post-imgs/bisection-method/fx-plot.png" target="_blank">
    <img src="/post-imgs/bisection-method/fx-plot.png"  alt="Plot of f(x)"   width="500px"   style="border-radius: 8px;"  />
  </a>
  
    <figcaption class="center" >Figure 2. Plot of f(x).</figcaption>
  
</figure>

<p>As we can see, the other solution is between <code>$x = 0.6$</code> and <code>$x = 1.0$</code>. We&rsquo;ll use these as our initial boundary points: <code>$a_1 = 0.6$</code> and <code>$b_1 = 1.0$</code>. We can choose a tolerance value of <code>$\epsilon = 10^{-6}$</code> and limit the number of iterations to 500. Here is the code for the Bisection Method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># Initial bounds where we believe the solution/root is.</span>
a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.6</span>  <span style="color:#75715e"># Left boundary</span>
b <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>  <span style="color:#75715e"># Right boundary</span>

TOL <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e-6</span>      <span style="color:#75715e"># Relative tolerance convergence criteria</span>
MAX_ITER <span style="color:#f92672">=</span> <span style="color:#ae81ff">500</span>  <span style="color:#75715e"># Max. number of iterations</span>

p_prev <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>    <span style="color:#75715e"># Keep track of old p-values</span>
soln <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>      <span style="color:#75715e"># Store final solution in this variable</span>
f_a <span style="color:#f92672">=</span> funct(a)  <span style="color:#75715e"># Evaluate left point</span>
<span style="color:#66d9ef">for</span> iters <span style="color:#f92672">in</span> range(MAX_ITER):   <span style="color:#75715e"># Iterate until max. iterations are reached.</span>
    
    p <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> ((b <span style="color:#f92672">-</span> a) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span>)     <span style="color:#75715e"># Determine center of the interval, p</span>
    f_p <span style="color:#f92672">=</span> funct(p)              <span style="color:#75715e"># Evaluate midpoint </span>

    <span style="color:#75715e"># Check if tolerance is satisfied</span>
    <span style="color:#66d9ef">if</span> f_p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0.0</span> <span style="color:#f92672">or</span> np<span style="color:#f92672">.</span>abs(p <span style="color:#f92672">-</span> p_prev) <span style="color:#f92672">/</span> np<span style="color:#f92672">.</span>abs(p) <span style="color:#f92672">&lt;</span> TOL:
        <span style="color:#75715e"># Break if tolerance is met, return answer!</span>
        soln <span style="color:#f92672">=</span> p
        <span style="color:#66d9ef">break</span>
    
    <span style="color:#75715e"># Determine new bounds depending on the values of f(a) and f(p)</span>
    <span style="color:#66d9ef">if</span> (np<span style="color:#f92672">.</span>sign(f_a) <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sign(f_p)) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.0</span>:
        a <span style="color:#f92672">=</span> p       <span style="color:#75715e"># If positive, move to the left</span>
        f_a <span style="color:#f92672">=</span> f_p
    <span style="color:#66d9ef">else</span>:
        b <span style="color:#f92672">=</span> p       <span style="color:#75715e"># Otherwise (if negative), move to the right</span>

    p_prev <span style="color:#f92672">=</span> p      <span style="color:#75715e"># Replace old with new</span>


<span style="color:#75715e"># PRINT RESULTS!</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Bisection Method Results:&#34;</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;    Final Tolerance: </span><span style="color:#e6db74">%g</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (np<span style="color:#f92672">.</span>abs(p <span style="color:#f92672">-</span> p_prev) <span style="color:#f92672">/</span> np<span style="color:#f92672">.</span>abs(p)))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;    Number of Iterations: </span><span style="color:#e6db74">%g</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (iters))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;    Solution: x = </span><span style="color:#e6db74">%g</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> (soln))
</code></pre></div><hr>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">Bisection Method Results:
    Final Tolerance: 9.35719e-07
    Number of Iterations: 18
    Solution: x = 0.815351
</code></pre></div><p>Therefore, <code>$x = 0.815351$</code> satisfies the equality <code>$xe^{2x} - \sqrt{x} = 4x$</code>. We can plot this point over top of the plot of <code>$f(x) = xe^{2x} - \sqrt{x} - 4x$</code> to verify our solution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">x_points <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0.6</span>, <span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">80</span>)

plt<span style="color:#f92672">.</span>figure()  <span style="color:#75715e"># Plot f(x)</span>
plt<span style="color:#f92672">.</span>plot(x_points, funct(x_points), label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;f(x)&#39;</span>)
plt<span style="color:#f92672">.</span>plot(soln, funct(soln), <span style="color:#e6db74">&#39;r*&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Root of f(x)&#39;</span>)
plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;Root of $f(x) = xe^{2x} - \sqrt{x} - 4x$&#39;</span>)
plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#39;x&#39;</span>)
plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;f(x)&#39;</span>)
plt<span style="color:#f92672">.</span>legend()
plt<span style="color:#f92672">.</span>grid()
</code></pre></div>
<figure class="center" >
  <a href="/post-imgs/bisection-method/fx-root.png" target="_blank">
    <img src="/post-imgs/bisection-method/fx-root.png"  alt="Plot root of f(x)"   width="500px"   style="border-radius: 8px;"  />
  </a>
  
    <figcaption class="center" >Figure 3. Thr root of f(x).</figcaption>
  
</figure>

<hr>
<h1 id="bisection-method-python-function">Bisection Method Python Function</h1>
<p>Finally, here is a pretty good Python implementation of the Bisection Method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> numpy <span style="color:#f92672">as</span> np


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">BisectionMethod</span>(a0, b0, funct, TOL<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-6</span>, MAX_ITER<span style="color:#f92672">=</span><span style="color:#ae81ff">500</span>):
    <span style="color:#e6db74">&#34;&#34;&#34;Solve for a function&#39;s root via the Bisection Method.
</span><span style="color:#e6db74">
</span><span style="color:#e6db74">    Args
</span><span style="color:#e6db74">    ----
</span><span style="color:#e6db74">        a0 (float): Initial left boundary point
</span><span style="color:#e6db74">        b0 (float): Initial right boundary point
</span><span style="color:#e6db74">        funct (function): Function of interest, f(x)
</span><span style="color:#e6db74">        TOL (float): Solution tolerance
</span><span style="color:#e6db74">        MAX_ITER (int): Maximum number of iterations
</span><span style="color:#e6db74">    
</span><span style="color:#e6db74">    Returns
</span><span style="color:#e6db74">    -------
</span><span style="color:#e6db74">        p (float): Root of f(x) within [a, b]
</span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
    p_prev <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>    <span style="color:#75715e"># Keep track of old p-values</span>
    soln <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>      <span style="color:#75715e"># Store final solution in this variable</span>
    f_a <span style="color:#f92672">=</span> funct(a)  <span style="color:#75715e"># Evaluate left point</span>
    <span style="color:#66d9ef">for</span> iters <span style="color:#f92672">in</span> range(MAX_ITER):   <span style="color:#75715e"># Iterate until max. iterations are reached.</span>
        p <span style="color:#f92672">=</span> a <span style="color:#f92672">+</span> ((b <span style="color:#f92672">-</span> a) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2.0</span>)     <span style="color:#75715e"># Determine center of the interval, p</span>
        f_p <span style="color:#f92672">=</span> funct(p)              <span style="color:#75715e"># Evaluate midpoint </span>

        <span style="color:#75715e"># Check if tolerance is satisfied</span>
        <span style="color:#66d9ef">if</span> f_p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0.0</span> <span style="color:#f92672">or</span> np<span style="color:#f92672">.</span>abs(p <span style="color:#f92672">-</span> p_prev) <span style="color:#f92672">/</span> np<span style="color:#f92672">.</span>abs(p) <span style="color:#f92672">&lt;</span> TOL:
            <span style="color:#75715e"># Break if tolerance is met, return answer!</span>
            soln <span style="color:#f92672">=</span> p
            <span style="color:#66d9ef">break</span>
        
        <span style="color:#75715e"># Determine new bounds depending on the values of f(a) and f(p)</span>
        <span style="color:#66d9ef">if</span> (np<span style="color:#f92672">.</span>sign(f_a) <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>sign(f_p)) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.0</span>:
            a <span style="color:#f92672">=</span> p       <span style="color:#75715e"># If positive, move to the left</span>
            f_a <span style="color:#f92672">=</span> f_p
        <span style="color:#66d9ef">else</span>:
            b <span style="color:#f92672">=</span> p       <span style="color:#75715e"># Otherwise (if negative), move to the right</span>

        p_prev <span style="color:#f92672">=</span> p      <span style="color:#75715e"># Replace old with new</span>

<span style="color:#75715e"># Replace with your own function</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">MyFunction</span>(x):
    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">-</span> <span style="color:#ae81ff">2.0</span>


<span style="color:#75715e"># Initial bounds where we believe the solution/root is.</span>
a <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>  <span style="color:#75715e"># Left boundary</span>
b <span style="color:#f92672">=</span> <span style="color:#ae81ff">4.0</span>  <span style="color:#75715e"># Right boundary</span>

root <span style="color:#f92672">=</span> BisectionMethod(a, b, MyFunction)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;Root x = &#34;</span>, root)
</code></pre></div>
		</div>

		<div class="post-tags">
			
				
					<nav class="nav tags">
							<ul class="flat">
								
								<li><a href="/tags/numerical-methods">numerical methods</a></li>
								
								<li><a href="/tags/coding">coding</a></li>
								
							</ul>
					</nav>
				
			
		</div>

		<div class="utternces-comments">
			<script src="https://utteranc.es/client.js"
    repo="michaelwro/mwrona-blog"
    issue-term="pathname"
    label="post comment"
    theme="github-dark"
    crossorigin="anonymous"
    async>
</script>
		</div>
		</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> Copyright © Michael Wrona 2021 |  Powered by <a href="https://gohugo.io">Hugo</a> and the <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a></div>
	</nav>
</div>



<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-176773333-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script>feather.replace()</script>
</body>
</html>
